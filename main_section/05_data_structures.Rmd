---
title: "Python for Bioinformatics"
author: Graeme Fox
date: "`r format(Sys.time(), '%B, %Y')`"
---
# Data Structures
We now know the different types of data points that Python can hold, whether
they are numbers, strings of text, or boolean values.

Typically, data points do not exist in isolation but instead are in a group. 
For example, consider a set of measurements of the peak day temperature over
a period of a week. A group of data points such as these can be stored in a list.

## Lists

<center>![](../images/data_icon.webp){height=300px}</center>

Lists are used to store multiple items within a single variable. Lists allow
duplicate values and once defined are always in the same order (ordered). 
Additional items can be added to the list and by default will appear at the 
bottom. Finally, lists are indexed meaning that we can easily retrieve the
1st, 2nd....nth item from the list.

### Add numeric data to a list

<center>![](../images/up_down.webp){height=300px}</center>

We define a list just like any other variable, but in order to add multiple
values to the list we enclose them in square braces and include a comma between
each value.

Add the following (made up) data representing some fold-change
values generated by an RNA-Seq type experiment.

```
gene_fold_change = [0.25, -0.42, 0.62, 1.27, -0.5, 0]
```

To add an additional value to the **end** of the list, we can use append():
```
gene_fold_change.append(0.33)

gene_fold_change
```

## Subsetting data
A value from the list can be retrieved by the **position** it occupies in the
list. The value in a certain position can be retrieved by selecting it in 
square braces.

This process of selecting a certain portion of data is known as subsetting.

**Note: Python data structures start at position zero. This can be confusing
but is a common feature of many programming languages**.

To select the first entry in the list, we therefore pass position "0" in the square
braces:
```
# Get the first value:
gene_fold_change[0]

# Get the fifth value:
gene_fold_change[4]
```

We can also use a negative value to count from the other end of the list. I.e. to get the last value in the list.

```
# Get the last value (wihtout knowing the length of the list)
gene_fold_change[-1]
```

The same technique also works to select a range of values from the list. The upper and lower position of the range to be selected given in square brackets, separated by a colon. 

```
# subset the third and fourth values
gene_fold_change[2:3]
```

To subset everything from a certain position onwards, leave the upper value blank. This also works to select everything before a certain position.
```
# subset the sixth value to the end
gene_fold_change[5:]

# subset everything up to the third value
gene_fold_change[:2]
```

## Set
A set is similar to a list except that it can only hold unique values. A set also 
differs from a list in that a set does 
not retain the order of the elements (I.e. it is unordered).

Sets are defined using the curly braces and a new element can be added to a 
set using the add() function.

Define a set containing plants found in a (fictional) pollen metabarcoding experiment. 

```

plants_set = {"Dandelion", "Buttercup", "Clover", "Poppy"}

plants_set
```

A second round of analysis founds an extra plant species and so we can add this in as well.

```
plants_set.add("Honeysuckle")

plants_set
```

Combining data from more samples might mean that duplicate plants were detected in the data. Adding plants that are already in the set has no effect as it cannot hold duplicate values.

```
plants_set.add("Buttercup", "Clover")

plants_set
```

## Transform a list to a set
Sometimes we have a list of non-unique values and it is useful to extract just the unique ones. We can do this by transforming a <b>list</b> into a <b>set</b>.


Add some gene IDs to a <b>list</b>:

```
gene_IDs = ["Agl", "Pygm", "Pgm2", "Ugp2", "Pygm", "Pgm2"]

# Note that a list can hold duplicate values
gene_IDs


```

We can transform the list into a set using set():

```
gene_set = set(gene_IDs)

# Very the duplicates have been removed
gene_set
```

## Dictionary

<center>![](../images/dictionary_icon.png){height=300px}</center>

The third data structure we will learn is the **dictionary**. A dictionary is an
ordered data structure which holds **pairs** of values; a **key** and a **value**.

For example, say we want to store the gene identifiers alongside our fold-change data
that we recorded earlier in a list. Each gene identifier/fold-change value are the key/value of the dictionary.

Dictionaries are also defined using the curly braces but a pair of values are given each time, separated by a colon.

Enter the following. Note that you need to press enter after each line.

```
gene_fold_change = {
  "Agl" : 0.25,
  "Pygm" : -0.42,
  "Pgm2" : 0.62,
  "Ugp2" : 1.27,
  "Gys1" : -0.5,
  "Phka1" : 0,
  "Phkg1" : 0.33
}
gene_fold_change
```

Dictionaries are **indexed** meaning that individual records can be retrieved 
very quickly (important if you are working with very large dictionaries).

We can retrieve the information for "Gys1" by using the identifier as the **key** 
and the dictionary will then return the **value**.

```
gene_fold_change["Gys1"]
```

New values can be added to the dictionary in a similar way to how they are retrieved:
```
gene_fold_change["ZT1"] = 3.2
gene_fold_change["ZT1"]
```

The pairing up of values in dictionaries is extremely useful if you are working
with DNA sequence files (Fasta or FastQ) as it offers an easy way of matching
up the read identifier with the DNA nucleotide data, for example. Once indexed, 
the individual records can then be accessed extremely quickly.

## Recap

<center>![](../images/recap.webp){height=300px}</center>


**Lists** hold an ordered catalogue of values. They can be accessed by their position
in the list (remembering to count from zero!). 

**Sets** can only hold unique values.

**Dictionaries** hold pairs of values (key and value) and can be used to very 
quickly access individual records, even when they are extremely large.

We are going to be using these data structures to look at and manipulate DNA sequence data specifically, but the principles apply to any datasets stored in these structures.