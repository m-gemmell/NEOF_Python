# Modifying DNA Data
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/modify_dna.png", auto_pdf = TRUE)
```

Suppose we want to filter raw sequence reads by some parameter.
For example, we could:

- Remove reads of a certain length.
- Remove sections of a sequence such as PCR primers.
- Filter reads by GC%.
- Detect amino acids.

In this chapter we will use our knowledge of __loops__ and __conditions__ to perform these tasks. Continue using __"04-Practical_python"__ notebook.

## Length filtering
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/filter_2.png", auto_pdf = TRUE)
```

Using what we know, we will create code to remove/filter reads shorter than a specified read-length threshold from a FastQ file.

```{python, eval=FALSE}
#Read in the fastq data
R_undulata_data = SeqIO.parse(wd + "/Python_course_data/R_undulata_WGS.fastq", "fastq")

#Initialise an empty list to hold the records that we want to keep
wanted_sequences = []

#Variable for choice of minimum length
#in this case we will choose 100
min_len = 100

#Loop through the fastq records
for record in R_undulata_data:
  #If condition to determine if sequence length is greater or equal to minimum length
  if len(record.seq) >= min_len:
    #Add the record to the list of records meets minimum length threshold
    wanted_sequences.append(record)

#Print statement to show number of reads retained after length filtering
print("Found " + str(len(wanted_sequences)) + " reads >= " + str(min_len) "bp in length.")
```

## Remove PCR primers
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/scissors_2.png", auto_pdf = TRUE)
```

Often you may want to check your sequence file for PCR primers, and remove them when they are found.
Using a __for__ __loop__ to move through the sequence file, we can check each DNA sequence read for the presence of a pre-defined primer sequence.
If it is present, we'll remove it.

We are going to check for the presence of the 13 nucleotide PCR primer "ACACTGCTGATCG" at the start of the reads using the `startswith()` __method__.
This __method__ checks whether a __string__ starts with a particular sub-string and returns __True__ or __False__. 
It is very useful for checking for primer sequences in our data.

The input for this primer removal step will be the 'wanted_sequences' __variable__ from the read filtering code (those of >=100bp in length).

For demonstration purposes we will first run code that will tell us the number of sequences which have the PCR sequence present.

__Note__: Below is the primer in triplet bases for ease of reading. Ensure you type it as one string with no spaces.

__ACA CTG CTG ATC G__

```{python, eval=FALSE}
#Assign PCR sequence variable
pcr_seq = "ACACTGCTGATCG"
#Initialise variable to sum number of records with PCR primer present
pcr_records = 0

#Loop through the sequence records
for record in wanted_sequences:
  #Check whether the sequence starts with the primer sequence
  if record.seq.startswith("ACACTGCTGATCG"):
    pcr_records = pcr_records + 1

print("Number of sequences with the PCR sequence present: " + str(pcr_records))
```

We have found that there are lots of sequences with the primer sequence present.
Now that we have identified their presence, let's trim them off the start of the reads.

Create and run the below code in a new __cell__. 
This will create a new __variable__ "trimmed_sequences". 
This will contain records that have been:

- Filtered to remove sequences shorter than 100bp.
- Trimmed to remove the PCR sequence ("ACACTGCTGATCG"). 
  - However, we also want to keep untrimmed sequences that did not contain the PCR sequence.

```{python, eval=FALSE}
#Define a list to hold the trimmed sequences
trimmed_sequences = []
#Assign PCR sequence variable
pcr_seq = "ACACTGCTGATCG"
#Initialise variable to sum number of records with PCR primer present
pcr_records = 0

#Loop through the sequence records
for record in wanted_sequences:
  #Check whether the sequence starts with the primer sequence
  if record.seq.startswith("ACACTGCTGATCG"):
    #Subset read from position 14 onwards and add to trimmed_sequences
    #This will remove the first 13 bases, the PCR sequence
    trimmed_sequences.append(record[13:])
    pcr_records = pcr_records + 1
  else:
    #Add untrimmed sequence to trimmed_sequences
    #this is because there is no PCR sequence present to trim off
    trimmed_sequences.append(record)

print("Number of sequences with the PCR sequence present: " + str(pcr_records))
```

Save and run the code one more time to see your three lines of information printed to screen.

## Filter by GC% range
```{r, fig.align = 'center',out.width= '50%', echo=FALSE }
knitr::include_graphics(path = "figures/range.png", auto_pdf = TRUE)
```

The next bit of coding will retain reads with a GC% between 40% and 60%. This is not normally something you would do but instead we've included it for demonstration purposes.

### and logical operator
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/and.png", auto_pdf = TRUE)
```

For this we will use the `and` __logical operator__. This allows us to test multiple comparisons `and` __if__ they are all `True` the __condition__ will return the output. Lets show a few examples.

First create a few demonstration variables.

```{python, eval = FALSE}
num_list = [1,2,3,4,5,6,7,8,9]
string_list = ["one","two","three","four","five","six","seven","eight","nine"]
```

Print numbers between 3 __and__ 7.

```{python, eval = FALSE}
#Loop through numbers
for num in num_list:
  #If number is greater than 3 and less than 7
  if num > 3 and num < 7:
    #Print number
    print(num)
```

Print numbers divisible by 2 that are also greater than 5.

```{python, eval = FALSE}
#Loop through numbers
for num in num_list:
  #If number is divisible by 2 and greater than 5
  if num%2 == 0 and num > 5:
    #Print number
    print(num)
```

Print strings longer than three characters __and__ has at least on letter __e__.

```{python, eval = FALSE}
#Loop through strings
for string in string_list:
  #If string length is greater than 3 and the "e" count is greater than 0
  if len(string) > 3 and string.count("e") > 0:
    #Print the string
    print(string)
```

Print strings shorter or equal to 3 characters __and__ that have no __e__.

```{python, eval = FALSE}
#Loop through strings
for string in string_list:
  #If string length is less than or equal to 3 and the "e" count is 0
  if len(string) <= 3 and string.count("e") == 0:
    #Print the string
    print(string)
```

In the above examples we have only used one `and` __operator__. You can use multiple but of course the more you use the more complex your __statement__ becomes.

### GC filter
```{r, fig.align = 'center',out.width= '50%', echo=FALSE }
knitr::include_graphics(path = "figures/40_60_range.png", auto_pdf = TRUE)
```

With the `and` __logical operator__ we can filter by a GC% range.

```{python, eval=FALSE}
#Read in the fastq data
R_undulata_data = SeqIO.parse(wd + "/Python_course_data/R_undulata_WGS.fastq", "fastq")

#Initialise an empty list to hold the records that we want to keep
gc_sequences = []

#Variables for choice of min and max gc%
min_gc = 40
max_gc = 60

#Loop through the fastq records
for record in R_undulata_data:
  #Calculate GC%
  gc_count = record.seq.upper().count("G") + record.seq.upper().count("C")
  gc_perc = (gc_count / len(record.seq)) * 100
  #If GC percent is greater than min and less than max
  if gc_perc > min_gc and gc_perc < max_gc:
    #Add the record to the list of records
    gc_sequences.append(record)

#Print statement to show number of reads retained after length filtering
print("Found " + str(len(gc_sequences)) + " reads with GC% range between " + 
  str(min_gc) + "% and " + str(max_gc) + "%.")
```

Ensure you understand the above code before continuing.
Please ask a demonstrator if you are unsure.

## Amino acid detection
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/amino_acid.png", auto_pdf = TRUE)
```

In this part you will translate part of each sequence with `.translate()`.
Then you will count the number of sequences that have at least one translated __Glutamine (Q)__ or _Serine (S)_.

### or logical operator
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/oar.png", auto_pdf = TRUE)
```

For this we will use the `or` __logical operator__. This allows us to test two comparisons and __if__ the first __or__ second is `True` the __condition__ will return the output. Lets go through a few examples.

We will use the same variables as our `and` __operator__ examples.

```{python, eval = FALSE}
num_list = [1,2,3,4,5,6,7,8,9]
string_list = ["one","two","three","four","five","six","seven","eight","nine"]
```

Print numbers greater than 4 __or__ if they are odd.

```{python, eval = FALSE}
#Loop through numbers
for num in num_list:
  #If number is greater than 4 or odd
  if num > 4 or num%2 == 1:
    #Print number
    print(num)
```

Print numbers less than or equal to 2 __or__ greater than or equal to 8.

```{python, eval = FALSE}
#Loop through numbers
for num in num_list:
  #If number is less than or equal to 2 or greater than or qual to 8
  if num <= 2 or num >= 8:
    #Print number
    print(num)
```

Print strings shorter than 4 characters __or__ longer than 4 characters.

```{python, eval = FALSE}
#Loop through strings
for string in string_list:
  #If string length is less than or greater than 4
  if len(string) < 4 or len(string) > 4:
    #Print the string
    print(string)
```

Print strings with an __n__ count of more than 1 __or__ an __e__ count of 0.

```{python, eval = FALSE}
#Loop through strings
for string in string_list:
  #If n count is greater than 0 or e count is 0
  if len(string) <= 3 and string.count("e") == 0:
    #Print the string
    print(string)
```

### Presence of at least one amino acid
```{r, fig.align = 'center',out.width= '6%', echo=FALSE }
knitr::include_graphics(path = "figures/presence.png", auto_pdf = TRUE)
```

With a `or` __logical operator__ we can count the number of translated sequences that have a __Glutamine (Q)__ __or__ _Serine (S)_.

When translating the sequence length needs to be divisible by three to match codon lengths. We will translate the first 10 codons (30 bases).

```{python, eval=FALSE}
#Read in the fastq data
R_undulata_data = SeqIO.parse(wd + "/Python_course_data/R_undulata_WGS.fastq", "fastq")

#Initialise a variable for the counter
counter = 0

#Variables for amino acids
aa_1 = "S"
aa_2 = "Q"

#Loop through the fastq records
for record in R_undulata_data:
  #Extract the first 30 bases
  subset_seq = record.seq[:30]
  #Translate sequence
  aa_seq = subset_seq.translate()
  #Amino acid counts
  aa_1_count = aa_seq.upper().count(aa_1)
  aa_2_count = aa_seq.upper().count(aa_2)
  #If aa_1 is present or aa_2 is present
  if aa_1_count > 0 or aa_2_count > 0:
    #Add 1 to counter
    counter = counter + 1

#Print statement to show number translated seqeunces with either of the amino acids
print("Found " + str(counter) + " reads with a translated " + 
  aa_1 + " or " + aa_2 + " in the first 10 codons.")
```

## Recap
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/recap.webp", auto_pdf = TRUE)
``` 

Using our knowledge of reading FASTQ files, looping through the data, and using conditions to check certain characteristics of the data we have been able to filter out short-reads and also remove primer contamination. We are starting to build a pipeline!

We will learn to write data out and store it in a new file in the next chapter.